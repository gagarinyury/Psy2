Понимаю. Нужны атомарные задания с кодом, тестами и быстрым ручным прогоном.

Задание №1 — каркас сервиса + БД + базовые эндпоинты

Цель

Поднять локально весь стек и получить:
    •    GET /health → ok.
    •    POST /case (заглушка, валидирует JSON по Pydantic, пишет в БД).
    •    POST /session (создаёт сессию).
    •    POST /turn (проходит оркестратор-заглушку и пишет телеметрию).
    •    Юнит-тесты pytest зелёные.
    •    Ручная проверка через curl.

Зависимости (версии зафиксировать в pyproject)
    •    fastapi==0.115.0
    •    uvicorn[standard]==0.30.6
    •    pydantic==2.9.2
    •    pydantic-settings==2.5.2
    •    sqlalchemy==2.0.34
    •    asyncpg==0.29.0
    •    alembic==1.13.2
    •    psycopg[binary]==3.2.1      # если сделаете sync DAO
    •    pgvector==0.2.5              # Python-обвязка
    •    redis==5.0.8
    •    httpx==0.27.2
    •    sentence-transformers==3.0.1 # пока только для CLI, не вызывать в этом задании
    •    loguru==0.7.2
    •    prometheus-client==0.20.0
    •    opentelemetry-sdk==1.27.0
    •    pytest==8.3.2
    •    hypothesis==6.112.3

Контейнеры (docker-compose.yml)
    •    app (FastAPI), postgres:16, redis:7, prometheus, grafana.
    •    Postgres с расширениями: CREATE EXTENSION IF NOT EXISTS vector;
    •    Переменные окружения через .env (см. ниже).

Файлы и структура

/app
  /api
    __init__.py
    router.py           # /health, /case, /session, /turn
  /core
    models.py           # Pydantic: CaseTruth, SessionState, Policies, I/O
    db.py               # подключение и сессия SQLAlchemy
    tables.py           # SQLA модели: cases, kb_fragments, sessions, telemetry_turns
    settings.py         # pydantic-settings
  /infra
    metrics.py          # Prometheus метрики и мидлварь
    logging.py          # loguru JSON
  /migrations           # alembic
  main.py               # FastAPI app factory
  pyproject.toml
  docker-compose.yml
  Makefile
  .env.example
  README.md
/tests
  test_health.py
  test_case_session_turn.py

Схемы (минимум полей)
    •    CaseTruth: dx_target: list[str], ddx: dict[str, float], hidden_facts: list[str], red_flags: list[str], trajectories: list[str]
    •    SessionStateCompact: affect: str, trust: float, fatigue: float, access_level: int, risk_status: str, last_turn_summary: str
    •    I/O:
    •    TurnRequest: therapist_utterance: str, session_state: SessionStateCompact, case_id: str, options: dict | None
    •    TurnResponse: patient_reply: str, state_updates: dict, used_fragments: list[str], risk_status: str, eval_markers: dict

Таблицы (alembic migration #001)
    •    cases(id uuid pk, case_truth jsonb, policies jsonb, version text, created_at timestamptz)
    •    kb_fragments(id uuid pk, case_id uuid fk, type text, text text, metadata jsonb, availability text, consistency_keys jsonb, embedding vector(1024))
    •    sessions(id uuid pk, case_id uuid fk, session_state jsonb, created_at, updated_at)
    •    telemetry_turns(id bigserial pk, session_id uuid fk, turn_no int, used_fragments jsonb, risk_status text, eval_markers jsonb, timings jsonb, costs jsonb, created_at)
    •    Индексы: GIN на jsonb, ivfflat/hnsw на embedding (создать, но пока не использовать).

Эндпоинты (заглушки логики)
    •    GET /health → {"status":"ok"}
    •    POST /case → валидирует CaseTruth + policies:any, пишет запись в cases, возвращает {case_id}
    •    POST /session → по case_id создаёт запись в sessions с дефолтным SessionStateCompact(trust=0.3, fatigue=0.1, risk_status="none"), возвращает {session_id}
    •    POST /turn → проверяет формат TurnRequest, пишет строку в telemetry_turns с turn_no, возвращает TurnResponse с:
    •    patient_reply="…" (эхо: первые 20 символов therapist_utterance)
    •    state_updates={"trust_delta":0.0}
    •    used_fragments=[], risk_status="none", eval_markers={"stub":true}

.env.example

APP_ENV=dev
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_DB=rag_patient
POSTGRES_USER=rag
POSTGRES_PASSWORD=ragpass
REDIS_URL=redis://redis:6379/0
OTEL_EXPORTER=none

Makefile (минимум)

up:        ## docker compose up
down:      ## docker compose down -v
migrate:   ## alembic upgrade head
test:      ## pytest -q
run:       ## uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

Тесты (pytest)
    •    test_health.py: запрос к /health → 200, body {"status":"ok"}
    •    test_case_session_turn.py:
    1.    POST /case с валидным CaseTruth → 200, case_id UUID
    2.    POST /session → 200, session_id UUID
    3.    POST /turn с короткой фразой → 200, patient_reply непустой, запись в telemetry_turns существует

Ручная проверка

curl -s localhost:8000/health
curl -s -X POST localhost:8000/case -H "content-type: application/json" -d @case.json
curl -s -X POST localhost:8000/session -H "content-type: application/json" -d '{"case_id":"<from-previous>"}'
curl -s -X POST localhost:8000/turn -H "content-type: application/json" -d '{"therapist_utterance":"Привет","session_state":{"affect":"neutral","trust":0.3,"fatigue":0.1,"access_level":1,"risk_status":"none","last_turn_summary":""},"case_id":"<id>","options":{}}'

Критерии приёмки
    •    docker compose up поднимает всё без ошибок.
    •    alembic upgrade head создаёт таблицы и расширение vector.
    •    Все тесты зелёные: pytest -q.
    •    Ручные curl возвращают ожидаемые ответы.
    •    Логи в JSON, базовые метрики Prometheus доступны на /metrics.

После приёмки этого шага перейдём к Заданию №2: CLI оффлайн-пайплайн кейса (case build/shard/embed/index/verify) и подключение pgvector-индекса к /turn без вызовов внешних моделей.
